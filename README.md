## WshEval

WshEval is a evaluator for Java-like expression.
It covers the numeric expression and supports variables in the expression

### Features
- Support Java numeric expression
  - binary operator `+`, `-`, `*`, `/`, `%`
  - unary operator `+`, `-` e.g. `--+-(1)` is -1
  - parenthesis
  - pre/post increment/decrement operator `++`, `--` e.g. `++a`
- Support variable assignment and variable in the expression
  - assign operator `=`, `+=`, `-=`, `*=`, `/=`, `%=`
- Support scientific notion
  - e.g. `12E3`, `12e+3`, `12.3e-4`
- Support integer, float, and auto type conversion

### How to use it?

#### Console Prompt

1. Create project with IntelliJ (File -> Project From Existing Source -> Import from external module -> Maven)
2. Make sure `src/main/java` is marked as source. `src/test/java` is marked as test
3. Execute main program in the package: `wsh.eval.Main`

```
Please enter the expression here. The result of evaluation will be output after press enter.
Supported Commands:
 -exit: Exit the program
 -vars: Print variables
 -clean: Remove all variables

a=123
>123(LONG)
b=456.78
>456.78(DOUBLE)
c=a+b
>579.78(DOUBLE)
vars
>(a=123(LONG),b=456.78(DOUBLE),c=579.78(DOUBLE))
clean
>Removed variables: [a, b, c]
exit
>Thanks for using the service. Good bye!
```

Tested Environments:
- Java SDK: Corretto-11.0.19
- IntelliJ:
  - IntelliJ IDEA 2023.1.3 (Community Edition)
    Build #IC-231.9161.38, built on June 20, 2023
  - Runtime version: 17.0.7+10-b829.16 amd64 
- Windows 10.0

#### Build your own evaluator

You can also use components to build your own evaluator application.
The lib contains basic code Interpreter components - Lexer, Parser, and Interpreter.

##### Lexer

A lexer is responsible for breaking the source code into individual tokens. It analyzes the input character stream and converts it into a sequence of tokens, which are meaningful units such as keywords, identifiers, operators, and literals.

e.g.
```java
    Lexer lexer = new Lexer();
    // consume(String) to initialize the lexer on consuming input expression 
    lexer.consume("a += 123.45e-10/(++b + c--)");
    List<Token> tokens = new ArrayList<>();
    Token t;
    // getToken() to get the next token on the input expression
    while((t = lexer.getToken()).getType() != TokenType.EOF) {
        tokens.add(t);
    }
    System.out.println(tokens);
    // [[VAR:a], [ADD_ASSIGN:+=], [NUM:123.45e-10], [DIV:/], [LPAREN:(], [DOUBLE_PLUS:++], [VAR:b], [PLUS:+], [VAR:c], [DOUBLE_MINUS:--], [RPAREN:)]]
```

#### Parser

The Parser utilizes the Lexer to get stream of tokens and constructs an abstract syntax tree (AST). The parser analyzes the structure and grammar of the code according to a specified grammar or set of rules. It ensures that the code follows the syntactic rules of the programming language and creates a hierarchical representation of the code's structure.

e.g.
```java
    Lexer lexer = new Lexer();
    Parser parser = new Parser(lexer);
    // parse expression to an AST
    TreeNode node = parser.parse("b=1+2");
```

The implemented syntax following definitions:

- expr: term ((PLUS | MINUS) term)  
- term: factor ((MUL | DIV | REM) factor)  
- factor : PLUS factor | MINUS factor | NUMBER | LPAREN expr RPAREN | VARIABLE(with pre/post increment/decrement)   
- PLUS(+), MINUS(-), MUL(*), DIV(/), REM(%), RPAREN((), LPAREN()), VARIABLE, NUMBER are tokens

e.g. 2*(7+3) will be parsed with below structure

![](https://ruslanspivak.com/lsbasi-part6/lsbasi_part6_decomposition.png)
(source: https://ruslanspivak.com/lsbasi-part6/)

and converted into a binary tree like
```agsl
    *
   / \
  2   +
     / \
    7   3
```

The supported tree nodes: Binary operator node, Unary operator node, Assign operator node, Number node, Variable node

#### Interpreter

The Interpreter traverses the AST generated by the parser and interprets each node in the tree, performing the corresponding actions based on the code's semantics.

e.g.
```java
    Lexer lexer = new Lexer();
    Parser parser = new Parser(lexer);
    VariableStore variableStore = new MapVariableStore();
    Interpreter interpreter = new Interpreter(parser, variableStore);
    // use interpret to evaluate an expression
    interpreter.interpret("a=(1+2.3)*4.5E-6");
    // use VariableStore to get the variable
    wsh.eval.number.Number aVal = interpreter.getVarStore().get("a");
```

#### Other
- `wsh.eval.number.Number` is the result value of the evaluation. It's a wrapper of Long, Double, and BigDecimal. 
When operating two Numbers, the result Number will be converted to the one with higher range.
- Use lib and tools: Guice, Lombok, Mockito, checkstyle, Jacoco
- Unit test coverage > 95%
  - to get coverage report. run `mvn clean test jacoco:report`. report will be in `target/site/jacoco/index.html`
- `mvn verify`: to run unit test, checkstyle, and Jacoco coverage check
