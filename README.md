## WshEval

WshEval is a evaluator for Java-like expression.
It covers the numeric expression and supports variables in the expression

```
a = (1+2)*(3-4)
b = ++a
c *= (a+b)*10
```

### Features
- Support numeric expression
  - binary operator `+`, `-`, `*`, `/`, `%`
  - unary operator `+`, `-` e.g. `--+-(1)` is -1
  - parenthesis
  - pre/post increment/decrement operator `++`, `--` e.g. `++a`
  - assign operator `=`, `+=`, `-=`, `*=`, `/=`, `%=`
  - variable
- Support scientific notion
  - e.g. `12E3`, `12e+3`, `12.3e-4`
- Support integer, float, arbitrary-precision signed decimal number, auto type conversion
- Support expression validations
  - Invalid number format e.g. `00123`, `123.123`, `1.1E2E3` 
  - Reserved keywords
  - Invalid characters in the expression
  - Invalid syntax

### How to use it?

#### Console Prompt

1. Create project with IntelliJ (File -> Project From Existing Source -> Import from external module -> Maven)
2. Make sure `src/main/java` is marked as source. `src/test/java` is marked as test
3. Execute main function in the package: `wsh.eval.ConsolePrompt`

```
Please enter the expression here. The result of evaluation will be output after press enter.
Supported Commands:
 -exit: Exit the program
 -vars: Print variables
 -clean: Remove all variables

a=123
>123(LONG)
b=456.78
>456.78(DOUBLE)
c=a+b
>579.78(DOUBLE)
vars
>(a=123(LONG),b=456.78(DOUBLE),c=579.78(DOUBLE))
clean
>Removed variables: [a, b, c]
exit
>Thanks for using the service. Good bye!
```

#### Build your Own Evaluator

You can also use components to build your own evaluator application.
The lib contains basic code Interpreter components - Lexer, Parser, and Interpreter.

##### Lexer

A lexer is responsible for breaking the source code into individual tokens. It analyzes the input character stream and converts it into a sequence of tokens, which are meaningful units such as keywords, identifiers, operators, and literals.

```java
    Lexer lexer = new Lexer();
    // consume(String) to initialize the lexer on consuming input expression 
    lexer.consume("a += 123.45e-10/(++b + c--)");
    List<Token> tokens = new ArrayList<>();
    Token t;
    // getToken() to get the next token on the input expression
    while((t = lexer.getToken()).getType() != TokenType.EOF) {
        tokens.add(t);
    }
    System.out.println(tokens);
    // [[VAR:a], [ADD_ASSIGN:+=], [NUM:123.45e-10], [DIV:/], [LPAREN:(], [DOUBLE_PLUS:++], [VAR:b], [PLUS:+], [VAR:c], [DOUBLE_MINUS:--], [RPAREN:)]]
```

Token Types:
- PLUS: `+`
- DOUBLE_PLUS: `++`
- MINUS: `-`
- DOUBLE_MINUS: `--`
- MUL: `*`
- DIV: `/`
- REM: `%`
- RPAREN: `(`
- LPAREN: `)`
- VARIABLE
- NUMBER

##### Parser

The Parser utilizes the Lexer to get stream of tokens and constructs an abstract syntax tree (AST). The parser analyzes the structure and grammar of the code according to a specified grammar or set of rules. It ensures that the code follows the syntactic rules of the programming language and creates a hierarchical representation of the code's structure.

```java
    Lexer lexer = new Lexer();
    Parser parser = new Parser(lexer);
    // parse expression to an AST
    TreeNode node = parser.parse("b=1+2");
```

The implemented syntax following definitions:

- expr: term ((PLUS | MINUS) term)  
- term: factor ((MUL | DIV | REM) factor)  
- factor : PLUS factor | MINUS factor | NUMBER | LPAREN expr RPAREN | (DOUBLE_PLUS | DOUBLE_MINUS) VARIABLE (DOUBLE_PLUS | DOUBLE_MINUS)

e.g. 2*(7+3) will be parsed with below structure

![](https://i.imgur.com/lEUXOKt.png)  

and be converted into an AST  
![](https://i.imgur.com/OMpmRLp.png)

The AST will be interpreted by the Interpreter

##### Interpreter

The Interpreter traverses the AST generated by the parser and interprets each node in the tree, performing the corresponding actions based on the code's semantics.

```java
    Lexer lexer = new Lexer();
    Parser parser = new Parser(lexer);
    VariableStore variableStore = new MapVariableStore();
    Interpreter interpreter = new Interpreter(parser, variableStore);
    // use interpret to evaluate an expression
    interpreter.interpret("a=(1+2.3)*4.5E-6");
    // use VariableStore to get the variable
    wsh.eval.number.Number aVal = interpreter.getVarStore().get("a");
```

### Other
- `wsh.eval.number.Number` is the value of evaluation result. It's a wrapper of `java.lang.Number` (currently support 
Long, Double, and BigDecimal). When operating on two Numbers, the result Number type will be the one with higher range.
- Use lib and tools: Guice, Lombok, Mockito, checkstyle, Jacoco, reflections
- Unit test coverage > 95%
  - to get coverage report. run `mvn clean test jacoco:report`. report will be generated in `target/site/jacoco/index.html`
- `mvn verify`: run unit test, checkstyle, and Jacoco coverage check (note that it can only run with JDK 11)

### Tested Environments 
- Java SDK: Amazon Corretto-11.0.19
- IntelliJ:
  - IntelliJ IDEA 2023.1.3 (Community Edition)
    Build #IC-231.9161.38, built on June 20, 2023
  - Runtime version: 17.0.7+10-b829.16 amd64
- Windows 11