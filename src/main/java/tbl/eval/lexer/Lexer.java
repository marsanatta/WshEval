package tbl.eval.lexer;

import tbl.eval.exceptions.InvalidTokenException;
import tbl.eval.number.Number;
import tbl.eval.number.NumberType;
import tbl.eval.token.Token;
import tbl.eval.token.TokenType;

import java.math.BigDecimal;

/**
 * Lexer process the input string to generate Tokens
 * which is the basic processing unit of the Parser
 */
public class Lexer {
    private static final BigDecimal BIG_DECIMAL_MAX_DOUBLE = BigDecimal.valueOf(Double.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_DOUBLE = BigDecimal.valueOf(Double.MIN_VALUE);
    private static final BigDecimal BIG_DECIMAL_MAX_LONG = BigDecimal.valueOf(Long.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_LONG = BigDecimal.valueOf(Long.MIN_VALUE);
    /**
     * Input string
     */
    private String text;

    /**
     * Current position of the input string
     */
    private int pos;

    /**
     * Current character of the input string
     */
    private Character curChar;

    /**
     * Current token generated by the lexer
     */
    private Token curToken;

    public Lexer(String text) {
        this.text = text;
        pos = 0;
        curChar = this.text.charAt(pos);
    }

    /**
     * Advance the current position and set the current character
     * @param steps number of step to advance
     */
    private void advance(int steps) {
        while (steps-- > 0) {
            int nextPos = pos + 1;
            if (nextPos > text.length() - 1) {
                curChar = null; // indicates end of the input
                pos = nextPos;
                break;
            } else {
                curChar = text.charAt(nextPos);
                pos = nextPos;
            }
        }
    }

    /**
     * Advance the current position and set the current character for 1 step
     */
    private void advance() {
        advance(1);
    }

    /**
     * Peek the previous character of the current character
     * @return character
     */
    private Character prev() {
        int peekPos = pos - 1;
        if (peekPos < 0) {
            return null;
        } else {
            return text.charAt(peekPos);
        }
    }

    /**
     * Peek the next character with given distance from the current character
     * @return character
     */
    private Character peek(int distance) {
        int peekPos = pos + distance;
        if (peekPos > text.length() - 1) {
            return null;
        } else {
            return text.charAt(peekPos);
        }
    }

    /**
     * Peek the next character of current character
     * @return character
     */
    private Character peek() {
        return peek(1);
    }

    /**
     * Move the position to skip whitespaces
     */
    private void skipWhitespace() {
        while (curChar != null && Character.isWhitespace(curChar)) {
            advance();
        }
    }

    private void fetchRestNumberString(StringBuilder sb) {
        int i = pos;
        while (i < text.length() && Character.isDigit(text.charAt(i)) ||text.charAt(i) == '.') {
            sb.append(text.charAt(i));
            i++;
        }
    }

    /**
     * Parse a Number
     */
    private Number parseNumber() throws InvalidTokenException {
        StringBuilder sb = new StringBuilder();
        if (curChar != null && curChar == '0') {
            fetchRestNumberString(sb);
            throw new InvalidTokenException("Number " + sb + " starts with zero");
        }

        int dotCnt = 0;
        while (curChar != null && (Character.isDigit(curChar) || curChar == '.')) {
            if (curChar == '.') {
                dotCnt++;
                if (dotCnt >= 2) {
                    fetchRestNumberString(sb);
                    throw new InvalidTokenException("Number " + sb + " has multiple decimal points");
                }
            }
            sb.append(curChar);
            advance();
        }

        String numStr = sb.toString();
        BigDecimal bigDecimal = new BigDecimal(numStr);
        if (bigDecimal.scale() > 0) {
            int compareMax = bigDecimal.compareTo(BIG_DECIMAL_MAX_DOUBLE);
            int compareMin = bigDecimal.compareTo(BIG_DECIMAL_MIN_DOUBLE);
            boolean isOverflow = compareMax > 0 || compareMin < 0;
            if (isOverflow) {
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            } else {
                return new Number(NumberType.DOUBLE, bigDecimal.doubleValue());
            }
        } else {
            try {
                Long longVal = bigDecimal.longValueExact();
                return new Number(NumberType.LONG, longVal);
            } catch (ArithmeticException e) {
                // overflow
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            }
        }
    }

    /**
     * Parse Variable name
     * @return variable name
     */
    private String parseVariable() {
        StringBuilder sb = new StringBuilder();
        while (curChar != null && Character.isLetterOrDigit(curChar)) {
            sb.append(curChar);
            advance();
        }
        return sb.toString();
    }

    private Token getMinusToken() {
        if (peek() != null && peek() == '-' && peek(2) != null && Character.isAlphabetic(peek(2))) {
            //--var
            advance(2);
            return new Token(TokenType.PRE_DECREMENT, "--");
        } else if (peek() != null && peek() == '-' && curToken != null && curToken.getType() == TokenType.VAR) {
            //var--
            advance(2);
            return new Token(TokenType.POST_DECREMENT, "++");
        } else {
            advance();
            return new Token(TokenType.MINUS, "-");
        }
    }

    private Token getPlusToken() {
        if (peek() != null && peek() == '+' && peek(2) != null && Character.isAlphabetic(peek(2))) {
            //++var
            advance(2);
            return new Token(TokenType.PRE_INCREMENT, "++");
        } else if (peek() != null && peek() == '+' && curToken.getType() == TokenType.VAR) {
            //var++
            advance(2);
            return new Token(TokenType.POST_INCREMENT, "++");
        } else {
            advance();
            return new Token(TokenType.PLUS, "+");
        }
    }

    /**
     * Do lexical analysis and return the next Token
     *
     * @return Token
     */
    public Token getToken() throws InvalidTokenException {
        Token token = null;
        while (curChar != null) {
            if (Character.isWhitespace(curChar)) {
                skipWhitespace();
                continue;
            } else if (Character.isAlphabetic(curChar)) {
                token = new Token(TokenType.VAR, parseVariable());
            } else if (Character.isDigit(curChar)) {
                token = new Token(TokenType.NUM, parseNumber());
            } else if (curChar == '+' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.ADD_ASSIGN, "+=");
            } else if (curChar == '-' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.SUB_ASSIGN, "-=");
            } else if (curChar == '*' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.MUL_ASSIGN, "*=");
            } else if (curChar == '/' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.DIV_ASSIGN, "/=");
            } else if (curChar == '%' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.REM_ASSIGN, "%=");
            } else if (curChar == '=') {
                advance();
                token = new Token(TokenType.ASSIGN, "=");
            } else if (curChar == '+') {
                token = getPlusToken();
            } else if (curChar == '-') {
                token = getMinusToken();
            } else if (curChar == '*') {
                advance();
                token = new Token(TokenType.MUL, "*");
            } else if (curChar == '/') {
                advance();
                token = new Token(TokenType.DIV, "/");
            } else if (curChar == '%') {
                advance();
                token = new Token(TokenType.REM, "%");
            } else if (curChar == '(') {
                advance();
                token = new Token(TokenType.LPAREN, "(");
            } else if (curChar == ')') {
                advance();
                token = new Token(TokenType.RPAREN, ")");
            } else {
                throw new InvalidTokenException("Invalid character: " + curChar);
            }
            curToken = token;
            return token;
        }
        return new Token(TokenType.EOF, null);
    }

}
