package tbl.eval.lexer;

import lombok.Getter;
import tbl.eval.exceptions.InvalidSyntaxException;
import tbl.eval.exceptions.InvalidTokenException;
import tbl.eval.number.Number;
import tbl.eval.number.NumberType;
import tbl.eval.token.Token;
import tbl.eval.token.TokenType;

import java.math.BigDecimal;

/**
 * Lexer process the input string to generate Tokens
 * which is the basic processing unit of the Parser
 */
@Getter
public class Lexer {
    private static final BigDecimal BIG_DECIMAL_MAX_DOUBLE = BigDecimal.valueOf(Double.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_DOUBLE = BigDecimal.valueOf(Double.MIN_VALUE);
    private static final BigDecimal BIG_DECIMAL_MAX_LONG = BigDecimal.valueOf(Long.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_LONG = BigDecimal.valueOf(Long.MIN_VALUE);
    /**
     * Input string
     */
    private String text;

    /**
     * Current position of the input string
     */
    private int pos;

    /**
     * Current character of the input string
     */
    private Character curChar;

    /**
     * Current token generated by the lexer
     */
    private Token curToken;

    /**
     * Start to consume the input text
     * @param text input text
     */
    public void consume(String text) {
        this.text = text;
        pos = 0;
        if (this.text.length() > 0)
            curChar = this.text.charAt(pos);
    }

    /**
     * Advance the current position and set the current character
     * @param steps number of step to advance
     */
    private void advance(int steps) {
        while (steps-- > 0) {
            int nextPos = pos + 1;
            if (nextPos > text.length() - 1) {
                curChar = null; // indicates end of the input
                pos = nextPos;
                break;
            } else {
                curChar = text.charAt(nextPos);
                pos = nextPos;
            }
        }
    }

    /**
     * Advance the current position and set the current character for 1 step
     */
    private void advance() {
        advance(1);
    }

    /**
     * Peek the next character with given distance from the current character
     * @return character
     */
    private Character peek(int distance) {
        int peekPos = pos + distance;
        if (peekPos > text.length() - 1) {
            return null;
        } else {
            return text.charAt(peekPos);
        }
    }

    /**
     * Peek the next character of current character
     * @return character
     */
    private Character peek() {
        return peek(1);
    }

    /**
     * Move the position to skip whitespaces
     */
    private void skipWhitespace() {
        while (curChar != null && Character.isWhitespace(curChar)) {
            advance();
        }
    }

    /**
     * Builder number start from current position
     * @param sb string builder
     */
    private void buildNumber(StringBuilder sb) {
        int i = pos;
        while (i < text.length() && (Character.isDigit(text.charAt(i)) ||text.charAt(i) == '.' || isScientificNotion(text.charAt(i)))) {
            sb.append(text.charAt(i));
            i++;
        }
    }

    private boolean isScientificNotion(char c) {
        return c == 'e' || c == 'E';
    }

    /**
     * Parse a Number
     */
    private Number parseNumber() throws InvalidTokenException {
        var sb = new StringBuilder();
        if (curChar != null && curChar == '0' && peek() != null && Character.isDigit(peek())) {
            buildNumber(sb);
            throw new InvalidTokenException(String.format("Number %s starts with zero", sb));
        }

        int dotCnt = 0;
        int eCnt = 0;
        while (curChar != null && (Character.isDigit(curChar) || curChar == '.' || isScientificNotion(curChar))) {
            if (curChar == '.') {
                dotCnt++;
                if (dotCnt >= 2) {
                    buildNumber(sb);
                    throw new InvalidTokenException(String.format("Number %s has multiple decimal points", sb));
                }
            } else if (isScientificNotion(curChar)) {
                eCnt++;
                if (eCnt >= 2) {
                    buildNumber(sb);
                    throw new InvalidTokenException(String.format("Number %s has multiple scientific notion", sb));
                }
            }
            sb.append(curChar);
            advance();
        }

        String numStr = sb.toString();
        BigDecimal bigDecimal = new BigDecimal(numStr);
        if (bigDecimal.scale() > 0) {
            int compareMax = bigDecimal.compareTo(BIG_DECIMAL_MAX_DOUBLE);
            int compareMin = bigDecimal.compareTo(BIG_DECIMAL_MIN_DOUBLE);
            boolean isOverflow = compareMax > 0 || compareMin < 0;
            if (isOverflow) {
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            } else {
                return new Number(NumberType.DOUBLE, bigDecimal.doubleValue());
            }
        } else {
            try {
                Long longVal = bigDecimal.longValueExact();
                return new Number(NumberType.LONG, longVal);
            } catch (ArithmeticException e) {
                // overflow
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            }
        }
    }

    /**
     * Parse Variable name
     * @return variable name
     */
    private String parseVariable() {
        StringBuilder sb = new StringBuilder();
        while (curChar != null && Character.isLetterOrDigit(curChar)) {
            sb.append(curChar);
            advance();
        }
        return sb.toString();
    }

    private Token getMinusToken() {
        if (peek() != null && peek() == '-') {
            advance(2);
            return new Token(TokenType.DOUBLE_MINUS, "--");
        } else {
            advance();
            return new Token(TokenType.MINUS, "-");
        }
    }

    private Token getPlusToken() {
        if (peek() != null && peek() == '+') {
            advance(2);
            return new Token(TokenType.DOUBLE_PLUS, "++");
        } else {
            advance();
            return new Token(TokenType.PLUS, "+");
        }
    }

    /**
     * Do lexical analysis to retrieve the next Token
     *
     * @return Token
     */
    public Token getToken() throws InvalidTokenException, InvalidSyntaxException {
        Token token;
        while (curChar != null) {
            if (Character.isWhitespace(curChar)) {
                skipWhitespace();
                continue;
            } else if (Character.isAlphabetic(curChar)) {
                token = new Token(TokenType.VAR, parseVariable());
            } else if (Character.isDigit(curChar)) {
                token = new Token(TokenType.NUM, parseNumber());
            } else if (curChar == '+' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.ADD_ASSIGN, "+=");
            } else if (curChar == '-' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.SUB_ASSIGN, "-=");
            } else if (curChar == '*' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.MUL_ASSIGN, "*=");
            } else if (curChar == '/' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.DIV_ASSIGN, "/=");
            } else if (curChar == '%' && peek() != null && peek() == '=') {
                advance(2);
                token = new Token(TokenType.REM_ASSIGN, "%=");
            } else if (curChar == '=') {
                advance();
                token = new Token(TokenType.ASSIGN, "=");
            } else if (curChar == '+') {
                token = getPlusToken();
            } else if (curChar == '-') {
                token = getMinusToken();
            } else if (curChar == '*') {
                advance();
                token = new Token(TokenType.MUL, "*");
            } else if (curChar == '/') {
                advance();
                token = new Token(TokenType.DIV, "/");
            } else if (curChar == '%') {
                advance();
                token = new Token(TokenType.REM, "%");
            } else if (curChar == '(') {
                advance();
                token = new Token(TokenType.LPAREN, "(");
            } else if (curChar == ')') {
                advance();
                token = new Token(TokenType.RPAREN, ")");
            } else {
                throw new InvalidTokenException("Invalid character: " + curChar);
            }
            curToken = token;
            return token;
        }
        return new Token(TokenType.EOF, null);
    }

}
