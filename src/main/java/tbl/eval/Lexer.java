package tbl.eval;

import lombok.Getter;
import tbl.eval.exceptions.InvalidTokenException;
import tbl.eval.number.Number;
import tbl.eval.number.NumberType;
import tbl.eval.token.Token;
import tbl.eval.token.TokenType;

import java.math.BigDecimal;
import java.util.Optional;

/**
 * Lexer process the input string to generate Tokens
 * which is the basic processing unit of the Parser
 */
@Getter
public class Lexer {
    private static final BigDecimal BIG_DECIMAL_MAX_DOUBLE = BigDecimal.valueOf(Double.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_DOUBLE = BigDecimal.valueOf(Double.MIN_VALUE);
    private static final BigDecimal BIG_DECIMAL_MAX_LONG = BigDecimal.valueOf(Long.MAX_VALUE);
    private static final BigDecimal BIG_DECIMAL_MIN_LONG = BigDecimal.valueOf(Long.MIN_VALUE);
    /**
     * Input string
     */
    private String text;

    /**
     * Current position of the input string
     */
    private int pos;

    /**
     * Current character of the input string
     */
    private Character curChar;

    /**
     * Current token generated by the lexer
     */
    private Token curToken;

    /**
     * Start to consume the input text
     * @param text input text
     */
    public void consume(String text) {
        this.text = text;
        pos = 0;
        if (this.text.length() > 0) {
            curChar = this.text.charAt(pos);
        }
    }

    /**
     * Advance the current position and set the current character
     * @param steps number of step to advance
     */
    private void advance(int steps) {
        while (steps-- > 0) {
            int nextPos = pos + 1;
            if (nextPos > text.length() - 1) {
                curChar = null; // indicates end of the input
                pos = nextPos;
                break;
            } else {
                curChar = text.charAt(nextPos);
                pos = nextPos;
            }
        }
    }

    /**
     * Advance the current position and set the current character for 1 step
     */
    private void advance() {
        advance(1);
    }

    /**
     * Peek the next character of current character
     * @return character
     */
    private Optional<Character> peek() {
        int peekPos = pos + 1;
        if (peekPos > text.length() - 1) {
            return Optional.empty();
        } else {
            return Optional.of(text.charAt(peekPos));
        }
    }

    /**
     * Move the position to skip whitespaces
     */
    private void skipWhitespace() {
        while (curChar != null && Character.isWhitespace(curChar)) {
            advance();
        }
    }

    /**
     * Builder number start from current position
     * @param sb string builder
     */
    private void buildNumber(StringBuilder sb) {
        int i = pos;
        while (i < text.length() && (Character.isDigit(text.charAt(i)) ||text.charAt(i) == '.' || isScientificNotion(text.charAt(i)))) {
            sb.append(text.charAt(i));
            // handle negative scientific notion
            if (isScientificNotion(text.charAt(i)) && i+1 < text.length() && (text.charAt(i+1) == '-' || text.charAt(i+1) == '+')) {
                sb.append(text.charAt(i+1));
                i++;
            }
            i++;
        }
    }

    private boolean isScientificNotion(char c) {
        return c == 'e' || c == 'E';
    }

    /**
     * Parse a Number
     */
    private Number parseNumber() throws InvalidTokenException {
        var sb = new StringBuilder();
        if (curChar != null && curChar == '0' && peek().isPresent() && Character.isDigit(peek().get())) {
            buildNumber(sb);
            throw new InvalidTokenException(String.format("Number %s starts with zero", sb));
        }

        int dotCnt = 0;
        int eCnt = 0;
        while (curChar != null && (Character.isDigit(curChar) || curChar == '.' || isScientificNotion(curChar))) {
            if (curChar == '.') {
                dotCnt++;
                if (dotCnt >= 2) {
                    buildNumber(sb);
                    throw new InvalidTokenException(String.format("Number %s has multiple decimal points", sb));
                }
            } else if (isScientificNotion(curChar)) {
                eCnt++;
                if (eCnt >= 2) {
                    buildNumber(sb);
                    throw new InvalidTokenException(String.format("Number %s has multiple scientific notion", sb));
                }
            }
            sb.append(curChar);
            // handle negative scientific notion
            if (isScientificNotion(curChar) && peek().isPresent() && (peek().get() == '-' || peek().get() == '+')) {
                sb.append(peek().get());
                advance();
            }
            advance();
        }

        String numStr = sb.toString();
        BigDecimal bigDecimal = new BigDecimal(numStr);
        if (bigDecimal.scale() > 0 || eCnt > 0) {
            int compareMax = bigDecimal.compareTo(BIG_DECIMAL_MAX_DOUBLE);
            int compareMin = bigDecimal.compareTo(BIG_DECIMAL_MIN_DOUBLE);
            boolean isOverflow = compareMax > 0 || compareMin < 0;
            if (isOverflow) {
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            } else {
                return new Number(NumberType.DOUBLE, bigDecimal.doubleValue());
            }
        } else {
            try {
                Long longVal = bigDecimal.longValueExact();
                return new Number(NumberType.LONG, longVal);
            } catch (ArithmeticException e) {
                // overflow
                return new Number(NumberType.BIG_DECIMAL, bigDecimal);
            }
        }
    }

    /**
     * Parse Variable name
     * @return variable name
     */
    private String parseVariable() {
        StringBuilder sb = new StringBuilder();
        while (curChar != null && Character.isLetterOrDigit(curChar)) {
            sb.append(curChar);
            advance();
        }
        return sb.toString();
    }

    private Token getMinusToken() {
        if (peek().isPresent() && peek().get() == '-') {
            advance(2);
            return Token.builder().type(TokenType.DOUBLE_MINUS).build();
        } else {
            advance();
            return Token.builder().type(TokenType.MINUS).build();
        }
    }

    private Token getPlusToken() {
        if (peek().isPresent() && peek().get() == '+') {
            advance(2);
            return Token.builder().type(TokenType.DOUBLE_PLUS).build();
        } else {
            advance();
            return Token.builder().type(TokenType.PLUS).build();
        }
    }

    /**
     * Do lexical analysis to retrieve the next Token
     *
     * @return Token
     */
    public Token getToken() throws InvalidTokenException {
        Token token;
        while (curChar != null) {
            if (Character.isWhitespace(curChar)) {
                skipWhitespace();
                continue;
            } else if (Character.isAlphabetic(curChar)) {
                token = Token.builder().type(TokenType.VAR).value(parseVariable()).build();
            } else if (Character.isDigit(curChar)) {
                token = Token.builder().type(TokenType.NUM).value(parseNumber()).build();
            } else if (curChar == '+' && peek().isPresent() && peek().get() == '=') {
                advance(2);
                token = Token.builder().type(TokenType.ADD_ASSIGN).build();
            } else if (curChar == '-' && peek().isPresent() && peek().get() == '=') {
                advance(2);
                token = Token.builder().type(TokenType.SUB_ASSIGN).build();
            } else if (curChar == '*' && peek().isPresent() && peek().get() == '=') {
                advance(2);
                token = Token.builder().type(TokenType.MUL_ASSIGN).build();
            } else if (curChar == '/' && peek().isPresent() && peek().get() == '=') {
                advance(2);
                token = Token.builder().type(TokenType.DIV_ASSIGN).build();
            } else if (curChar == '%' && peek().isPresent() && peek().get() == '=') {
                advance(2);
                token = Token.builder().type(TokenType.REM_ASSIGN).build();
            } else if (curChar == '=') {
                advance();
                token = Token.builder().type(TokenType.ASSIGN).build();
            } else if (curChar == '+') {
                token = getPlusToken();
            } else if (curChar == '-') {
                token = getMinusToken();
            } else if (curChar == '*') {
                advance();
                token = Token.builder().type(TokenType.MUL).build();
            } else if (curChar == '/') {
                advance();
                token = Token.builder().type(TokenType.DIV).build();
            } else if (curChar == '%') {
                advance();
                token = Token.builder().type(TokenType.REM).build();
            } else if (curChar == '(') {
                advance();
                token = Token.builder().type(TokenType.LPAREN).build();
            } else if (curChar == ')') {
                advance();
                token = Token.builder().type(TokenType.RPAREN).build();
            } else {
                throw new InvalidTokenException("Invalid character: " + curChar);
            }
            curToken = token;
            return token;
        }
        return Token.builder().type(TokenType.EOF).build();
    }

}
