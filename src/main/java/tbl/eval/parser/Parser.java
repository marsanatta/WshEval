package tbl.eval.parser;

import tbl.eval.ast.*;
import tbl.eval.exceptions.InvalidSyntaxException;
import tbl.eval.exceptions.InvalidTokenException;
import tbl.eval.lexer.Lexer;
import tbl.eval.token.Token;
import tbl.eval.token.TokenType;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Parse tokens generated by lexer into abstract syntax tree
 */
public class Parser {
    private static final Set<TokenType> TOKEN_TYPE_ASSIGN_SET = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TokenType.ASSIGN,
                    TokenType.ADD_ASSIGN,
                    TokenType.SUB_ASSIGN,
                    TokenType.MUL_ASSIGN,
                    TokenType.DIV_ASSIGN,
                    TokenType.REM_ASSIGN
            )));
    private static final Set<TokenType> TOKEN_TYPE_EXPR_OP_SET = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TokenType.PLUS,
                    TokenType.MINUS
            )));

    private static final Set<TokenType> TOKEN_TYPE_TERM_OP_SET = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TokenType.MUL,
                    TokenType.DIV,
                    TokenType.REM
            )));

    private static final Set<TokenType> TOKEN_TYPE_PRE_INCR_DECR_SET = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TokenType.PRE_INCREMENT,
                    TokenType.PRE_DECREMENT
            ))
    );

    private static final Set<TokenType> TOKEN_TYPE_POST_INCR_DECR_SET = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TokenType.POST_INCREMENT,
                    TokenType.POST_DECREMENT
                    ))
    );
    private Lexer lexer;
    private Token curToken;
    public Parser(Lexer lexer) throws InvalidTokenException {
        this.lexer = lexer;
        this.curToken = lexer.getToken(); // set initial token
    }

    /**
     * Compare the current token with the expected token types.
     * If they match, then "eat" the current token, and assign curToken to next token.
     * Otherwise, throw exception because of invalid syntax
     * @param types expected token types
     * @return the eaten token
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private Token eat(Set<TokenType> types) throws InvalidTokenException, InvalidSyntaxException {
        Token eatenNode = curToken;
        if (types.contains(curToken.getType())) {
            curToken = lexer.getToken();
        } else {
            throw new InvalidSyntaxException("Invalid syntax at token:" + curToken + " expect any from " + types);
        }
        return eatenNode;
    }

    /**
     * Compare the current token with the expected token type.
     * If they match, then "eat" the current token, and assign curToken to next token.
     * Otherwise, throw exception because of invalid syntax
     * @param type expected token type
     * @return the eaten token
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private Token eat(TokenType type) throws InvalidTokenException, InvalidSyntaxException {
        Token eatenNode = curToken;
        if (curToken.getType() == type) {
            curToken = lexer.getToken();
        } else {
            throw new InvalidSyntaxException("Invalid syntax at token:" + curToken + " expect " + type);
        }
        return eatenNode;
    }

    /**
     * Parse an assign expression
     * @return Assign expression node
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private TreeNode parseAssignExpr() throws InvalidSyntaxException, InvalidTokenException {
        TreeNode left = parseVariable();
        Token assignOp = curToken;
        eat(TOKEN_TYPE_ASSIGN_SET);
        TreeNode right = expr();
        return new AssignNode(left, assignOp, right);
    }

    /**
     * Parse a expr node
     * expr: term ((PLUS | MINUS) term)*
     * @return tree node
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private TreeNode expr() throws InvalidTokenException, InvalidSyntaxException {
        TreeNode node = term();
        while (TOKEN_TYPE_EXPR_OP_SET.contains(curToken.getType())) {
            Token opToken = curToken;
            eat(TOKEN_TYPE_EXPR_OP_SET);
            node = new BinaryOpNode(node, opToken, term());
        }
        return node;
    }

    /**
     * Parse a term node
     * term: factor ((MUL | DIV) factor)*
     * @return tree node
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private TreeNode term() throws InvalidTokenException, InvalidSyntaxException {
        TreeNode node = factor();
        while (TOKEN_TYPE_TERM_OP_SET.contains(curToken.getType())) {
            Token opToken = curToken;
            eat(TOKEN_TYPE_TERM_OP_SET);
            node = new BinaryOpNode(node, opToken, factor());
        }
        return node;
    }

    /**
     * Parse a factor node
     * factor : PLUS factor | MINUS factor | NUMBER | LPAREN expr RPAREN | VARIABLE
     * @return tree node
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private TreeNode factor() throws InvalidTokenException, InvalidSyntaxException {
        Token token = curToken;
        switch (token.getType()) {
            case PLUS:
                eat(TokenType.PLUS);
                return new UnaryOpNode(token, factor());
            case MINUS:
                eat(TokenType.MINUS);
                return new UnaryOpNode(token, factor());
            case NUM:
                eat(TokenType.NUM);
                return new NumberNode(token);
            case LPAREN:
                eat(TokenType.LPAREN);
                TreeNode node = expr();
                eat(TokenType.RPAREN);
                return node;
            case VAR, PRE_INCREMENT, PRE_DECREMENT:
                return parseVariable();
            default:
                throw new InvalidSyntaxException("Encounter invalid token " + curToken + " while parsing. Expect a factor");
        }
    }

    /**
     * Parse the input text from tokens generated by the given Lexer
     * @return Root node of abstract syntax tree
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    public TreeNode parse() throws InvalidTokenException, InvalidSyntaxException {
        TreeNode root = parseAssignExpr();
        if (curToken.getType() != TokenType.EOF) {
            throw new InvalidSyntaxException("Encounter invalid token " + curToken + " while parsing. Expect an EOF");
        }
        return root;
    }

    /**
     * Parse tokens to generate a variable node
     * @return A variable node
     * @throws InvalidTokenException input has invalid token
     * @throws InvalidSyntaxException input has invalid syntax
     */
    private TreeNode parseVariable() throws InvalidTokenException, InvalidSyntaxException {
        Token preIncrDecrToken = null;
        if (TOKEN_TYPE_PRE_INCR_DECR_SET.contains(curToken.getType())) {
            preIncrDecrToken = curToken;
            eat(TOKEN_TYPE_PRE_INCR_DECR_SET);
        }
        Token varToken = eat(TokenType.VAR);
        VarNode varNode = new VarNode(varToken, (String)varToken.getValue());
        varNode.setPreIncrDecrToken(preIncrDecrToken);

        if (TOKEN_TYPE_POST_INCR_DECR_SET.contains(curToken.getType())) {
            if (preIncrDecrToken != null) {
                throw new InvalidSyntaxException("Variable " + varNode.getVarToken() + " have both pre and post increment/decrement operator");
            }
            Token postIncrDecrToken = curToken;
            eat(TOKEN_TYPE_POST_INCR_DECR_SET);
            varNode.setPostIncrDecrToken(postIncrDecrToken);
        }
        return varNode;
    }

}
